<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>bridge_sim.temperature API documentation</title>
<meta name="description" content="Time series of responses to temperature â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bridge_sim.temperature</code></h1>
</header>
<section id="section-intro">
<p>Time series of responses to temperature.</p>
<p>Parsed temperature data is from:
<a href="https://www1.ncdc.noaa.gov/pub/data/uscrn/products/subhourly01/2019/">https://www1.ncdc.noaa.gov/pub/data/uscrn/products/subhourly01/2019/</a></p>
<p>Usage example of this module:</p>
<pre><code>from datetime import datetime
from bridge_sim import temperature

# First load some weather data.
weather = temperature.load("holly-springs")
weather["temp"] = temperature.resize(temps_df["temp"], year=2019)
weather = temperature.from_to_mins(
    temp_df,
    from_=datetime.strptime("01/05/19 00:00", "%d/%m/%y %H:%M"),
    to=datetime.strptime("31/05/19 23:59", "%d/%m/%y %H:%M"),
)

# Then get the temperature effect and interpolate over signal.
effect = temperature.effect(config, RT.StrainXXB, [Point(x=51)], weather)
effect = util.apply(effect, some_signal)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Time series of responses to temperature.

Parsed temperature data is from:
https://www1.ncdc.noaa.gov/pub/data/uscrn/products/subhourly01/2019/

Usage example of this module:

    from datetime import datetime
    from bridge_sim import temperature

    # First load some weather data.
    weather = temperature.load(&#34;holly-springs&#34;)
    weather[&#34;temp&#34;] = temperature.resize(temps_df[&#34;temp&#34;], year=2019)
    weather = temperature.from_to_mins(
        temp_df,
        from_=datetime.strptime(&#34;01/05/19 00:00&#34;, &#34;%d/%m/%y %H:%M&#34;),
        to=datetime.strptime(&#34;31/05/19 23:59&#34;, &#34;%d/%m/%y %H:%M&#34;),
    )

    # Then get the temperature effect and interpolate over signal.
    effect = temperature.effect(config, RT.StrainXXB, [Point(x=51)], weather)
    effect = util.apply(effect, some_signal)

&#34;&#34;&#34;

import datetime
import os
from copy import deepcopy
from datetime import datetime, timedelta
from typing import List, Optional, Tuple

import numpy as np
import pandas as pd
from scipy.interpolate import interp1d
from sklearn.linear_model import LinearRegression

from bridge_sim import sim
from bridge_sim.model import Config, Point, ResponseType
from bridge_sim.util import print_d, print_i, print_w, project_dir

# D: str = &#34;classify.temperature&#34;
D: bool = False


def parse_line(line: str):
    &#34;&#34;&#34;Parse a line of NOAA weather data.

    Args:
        line: a line of NOAA weather data.

    Returns: a tuple of (datetime, air temperature, solar radiation).

    &#34;&#34;&#34;
    # 23803 20190101 0005 20181231 1805      3  -89.43   34.82    12.4
    # 0.0      0 0    10.9 C 0    88 0 -99.000 -9999.0  1115 0   0.79 0
    line = line.split()
    ds = line[1]  # Date string.
    ts = line[2]  # Time string.
    year, mon, day, hr, mn = (ds[0:4], ds[4:6], ds[6:8], ts[0:2], ts[2:4])
    # 2011-11-04T00:05
    dt = datetime.fromisoformat(f&#34;{year}-{mon}-{day}T{hr}:{mn}&#34;)
    return [dt, float(line[-15]), float(line[-13])]


def load(
    name: str, temp_quantile: Tuple[float, float] = (0.001, 0.999)
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Load weather data from a file.

    The returned DataFrame will have duplicate datetimes removed, will have NaN
    and INF values removed and will have &#39;temp_quantile&#39; lower and upper
    quantiles removed. Missing values will NOT be filled in.

    Args:
        name: name of the file to load (without extension).
        temp_quantile: tuple of lower and upper air temperature quantiles to
            ignore (incase of extreme values).

    Returns: a DataFrame of datetimes, air temperature and solar radiation.

    &#34;&#34;&#34;
    # If the file is already parsed, return it..
    name_path = os.path.join(project_dir(), &#34;data/temperature&#34;, name + &#34;.txt&#34;)
    saved_path = name_path + &#34;.parsed&#34;
    if os.path.exists(saved_path):
        df = pd.read_csv(saved_path, index_col=0, parse_dates=[&#34;datetime&#34;])
        lq = df[&#34;temp&#34;].quantile(temp_quantile[0])
        hq = df[&#34;temp&#34;].quantile(temp_quantile[1])
        print(f&#34;Temperature {temp_quantile} quantiles = {lq}, {hq}&#34;)
        df = df[(df[&#34;temp&#34;] &gt;= lq) &amp; (df[&#34;temp&#34;] &lt;= hq)]
        return df
    # ..otherwise read and parse the data.
    with open(name_path) as f:
        temps = list(map(parse_line, f.readlines()))
    # Remove NANs.
    for line_ind, [dt, temp, solar] in enumerate(temps):
        if np.isnan(temp):
            print_i(f&#34;NAN in {name} temperature&#34;)
            temps[line_ind][1] = temps[line_ind - 1][1]
        if np.isnan(solar):
            print_i(f&#34;NAN in {name} solar radiation&#34;)
            temps[line_ind][2] = temps[line_ind - 1][2]
    # Pack it into a DataFrame.
    df = pd.DataFrame(temps, columns=[&#34;datetime&#34;, &#34;temp&#34;, &#34;solar&#34;])
    # Remove duplicate datetimes.
    len_before = len(df)
    df = df.drop_duplicates(subset=[&#34;datetime&#34;], keep=&#34;first&#34;)
    len_after = len(df)
    print_i(f&#34;Removed {len_before - len_after} duplicates, now {len_after} rows&#34;)
    # Sort by datetime.
    df = df.sort_values(by=[&#34;datetime&#34;])
    # Save to file and return that DataFrame.
    df.to_csv(saved_path)
    return load(name=name)


def resize(
        temps: List[float],
        tmin: Optional[int] = None,
        tmax: Optional[int] = None,
        year: Optional[int] = None,
) -&gt; List[float]:
    &#34;&#34;&#34;Resize temperatures into a range.

    Args:
        temps: a list of temperatures.
        tmin: minimum temperature in returned range.
        tmax: maximum temperature in returned range.
        year: preset values for tmin and tmax, 2018 or 2019. If given there&#39;s no
            need to provide the tmin and tmax values.

    Returns: the given temperatures interpolated into a new range.

    &#34;&#34;&#34;
    if year is not None:
        if year == 2018:
            tmin, tmax = -2, 32
        elif year == 2019:
            tmin, tmax = -5, 35
        else:
            raise NotImplementedError(f&#34;Unknown year {year}&#34;)
    assert tmin &lt; 0
    assert tmax &gt; 30
    print_i(f&#34;Resizing temps into: T_min, T_max = ({tmin}, {tmax})&#34;)
    return interp1d(
        np.linspace(min(temps), max(temps), 10000), np.linspace(tmin, tmax, 10000)
    )(temps)


def from_to_mins(df: pd.DataFrame, from_: datetime, to: datetime) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Minutely weather data interpolated into a range (inclusive).

    Args:
        df: weather data loaded with &#39;load&#39;.
        from_: datetime of the first minute in the range.
        to: datetime of the last minute in the range.

    Returns: a DataFrame with values interpolated in the given range.

    &#34;&#34;&#34;
    # Create times and temperatures from given data.
    dates, temps, solar = df[&#34;datetime&#34;], df[&#34;temp&#34;], df[&#34;solar&#34;]
    times = dates.apply(lambda d: datetime.timestamp(d))
    # Create times that are expected to return.
    result_dates, result_times = [], []
    curr = from_
    while curr &lt;= to:
        result_dates.append(curr)
        result_times.append(datetime.timestamp(curr))
        curr += timedelta(minutes=1)
    # Interpolate to get results.
    result_temps = interp1d(times, temps, fill_value=&#34;extrapolate&#34;)(result_times)
    result_solar = interp1d(times, solar, fill_value=&#34;extrapolate&#34;)(result_times)
    # Pack it into a DataFrame.
    df = pd.DataFrame(
        np.array([result_dates, result_temps, result_solar]).T,
        columns=[&#34;datetime&#34;, &#34;temp&#34;, &#34;solar&#34;],
    )
    # Sort.
    df = df.sort_values(by=[&#34;datetime&#34;])
    df[&#34;temp&#34;] = pd.to_numeric(df[&#34;temp&#34;])
    df[&#34;solar&#34;] = pd.to_numeric(df[&#34;solar&#34;])
    return df


def temp_profile(temps: List[float], solar: List[float]):
    &#34;&#34;&#34;Bottom and top bridge deck temperatures for given weather data.

    Args:
        temps: list of air temperature.
        solar: list of solar radiation.

    Returns: tuple of two lists, bottom and top bridge deck temperatures.

    &#34;&#34;&#34;
    bd = 0.001

    temps_b = [temps[0]]
    for i, temp_a in enumerate(temps[1:]):
        temps_b.append((1 - bd) * temps_b[i - 1] + bd * temp_a)

    sn = 0.008
    ss = 0.0001
    temps_s = [temps[0]]

    for i, (temp_a, solar) in enumerate(zip(temps[1:], solar[1:])):
        if False:
            recent_max = np.max(temps[max(0, recent_start) : i])
            temps_s.append((1 - sd) * temps_s[i - 1] + sd * recent_max)
        else:
            temps_s.append((1 - sn - ss) * temps_s[i - 1] + sn * temp_a + ss * solar)

    return np.array(temps_b), np.array(temps_s)


def effect(
    config: Config,
    response_type: ResponseType,
    points: List[Point],
    weather: Optional[pd.DataFrame] = None,
    temps_bt: Optional[Tuple[List[float], List[float]]] = None,
    d: bool = False,
) -&gt; List[List[float]]:
    &#34;&#34;&#34;Temperature effect at points for some weather data.

    The returned responses contain the post-processing necessary for strain.

    Args:
        config: Config, simulation configuration object.
        response_type: type of sensor response to temp. effect.
        points:  points at which to calculate temperature effect.
        weather: DataFrame to calculate temperature profile time series from.
        temps_bt: if &#39;weather&#39; is not provided you can pass in a tuple of the
            temperature at the bottom and top of the bridge deck.
        d: a flag for debugging.

    Returns: NumPy array of temperature effect, indexed by point then time.

    &#34;&#34;&#34;
    print_w(&#34;Make sure calculating profile from entire year!!&#34;)
    # Unit effect from uniform temperature loading.
    uniform_responses = sim.responses.load(
        config=config, response_type=response_type, temp_deltas=(1, None)
    )
    linear_responses = sim.responses.load(
        config=config, response_type=response_type, temp_deltas=(None, 1)
    )
    if response_type.is_strain():
        uniform_responses = uniform_responses.add_temp_strain(config=config, temp_deltas=(1, None))
        linear_responses = linear_responses.add_temp_strain(config=config, temp_deltas=(None, 1))
    print_i(&#34;Loaded unit temperature responses&#34;)

    # Effect to unit temperature loading only at requested points.
    unit_uniforms = np.array(uniform_responses.at_decks(points))
    unit_linears = np.array(linear_responses.at_decks(points))
    assert len(unit_uniforms.shape) == 1
    assert unit_uniforms.shape[0] == len(points)

    # Determine temperature profile.
    if temps_bt is None:
        temps_bt = temp_profile(temps=weather[&#34;temp&#34;], solar=weather[&#34;solar&#34;])
    temps_bottom, temps_top = np.array(temps_bt[0]), np.array(temps_bt[1])
    temps_half = (temps_bottom + temps_top) / 2
    temps_linear = temps_top - temps_bottom
    temps_uniform = temps_half - config.bridge.ref_temp_c

    # print(f&#34;temps_bottom.shape = {temps_bottom.shape}&#34;)
    # print(f&#34;temps_top.shape = {temps_top.shape}&#34;)
    # print(f&#34;temps_half.shape = {temps_half.shape}&#34;)
    print_d(D, f&#34;tb = {temps_bottom[:3]}&#34;)
    print_d(D, f&#34;tt = {temps_top[:3]}&#34;)
    print_d(D, f&#34;th = {temps_half[:3]}&#34;)
    print_d(D, f&#34;temps linear = {temps_linear[:3]}&#34;)
    print_d(D, f&#34;temps uniform = {temps_uniform[:3]}&#34;)

    # Combine uniform and linear responses.
    uniform_responses = np.array(
        [unit_uniform * temps_half for unit_uniform in unit_uniforms]
    )
    linear_responses = np.array(
        [unit_linear * temps_linear for unit_linear in unit_linears]
    )
    # print(f&#34;uniform_responses.shape = {uniform_responses.shape}&#34;)
    # print(f&#34;linear_responses.shape = {linear_responses.shape}&#34;)
    print_d(D, f&#34;uniform responses = {uniform_responses[:3]}&#34;)
    print_d(D, f&#34;linear responses = {linear_responses[:3]}&#34;)
    if d:
        return temps_uniform, temps_linear, uniform_responses + linear_responses
    return uniform_responses + linear_responses


def remove_daily(num_samples, signal):
    &#34;&#34;&#34;Remove from the given signal by interpolating at &#39;num_samples&#39; points.

    Data must be of shape n samples x f features.

    Args:
        num_samples: number of samples e.g. 24.
        signal: the temperature or feature signal.

    Returns: a tuple of the interpolated signal, and the signal to remove.

    &#34;&#34;&#34;
    # &#39;num_samples + 1&#39; indices into given signal.
    indices = list(map(int, np.linspace(0, len(signal) - 1, num_samples + 1)))
    # Mean value of the signal between each pair of indices,
    # and new indices, at center between each pair of indices.
    y_samples, new_indices = [], []
    for i_lo, i_hi in zip(indices[:-1], indices[1:]):
        y_samples.append(np.mean(signal[i_lo:i_hi]))
        new_indices.append(int((i_lo + i_hi) / 2))
    rm = interp1d(new_indices, y_samples, fill_value=&#34;extrapolate&#34;)(
        np.arange(len(signal))
    )
    return rm, deepcopy(rm) - rm[0]


def regress_and_errors(x, y):
    &#34;&#34;&#34;Linear regression predictor, and error from each given point.&#34;&#34;&#34;
    lr = LinearRegression().fit(x.reshape(-1, 1), y)
    errors = []
    for x_, y_ in zip(x, y):
        errors.append(abs(y_ - lr.predict([[x_]])[0]))
    return lr, np.array(errors)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bridge_sim.temperature.effect"><code class="name flex">
<span>def <span class="ident">effect</span></span>(<span>config:Â <a title="bridge_sim.model.Config" href="../model/index.html#bridge_sim.model.Config">Config</a>, response_type:Â <a title="bridge_sim.model.ResponseType" href="../model/index.html#bridge_sim.model.ResponseType">ResponseType</a>, points:Â List[<a title="bridge_sim.model.Point" href="../model/index.html#bridge_sim.model.Point">Point</a>], weather:Â Union[pandas.core.frame.DataFrame,Â NoneType]Â =Â None, temps_bt:Â Union[Tuple[List[float],Â List[float]],Â NoneType]Â =Â None, d:Â boolÂ =Â False) ->Â List[List[float]]</span>
</code></dt>
<dd>
<div class="desc"><p>Temperature effect at points for some weather data.</p>
<p>The returned responses contain the post-processing necessary for strain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>Config, simulation configuration object.</dd>
<dt><strong><code>response_type</code></strong></dt>
<dd>type of sensor response to temp. effect.</dd>
<dt><strong><code>points</code></strong></dt>
<dd>points at which to calculate temperature effect.</dd>
<dt><strong><code>weather</code></strong></dt>
<dd>DataFrame to calculate temperature profile time series from.</dd>
<dt><strong><code>temps_bt</code></strong></dt>
<dd>if 'weather' is not provided you can pass in a tuple of the
temperature at the bottom and top of the bridge deck.</dd>
<dt><strong><code>d</code></strong></dt>
<dd>a flag for debugging.</dd>
</dl>
<p>Returns: NumPy array of temperature effect, indexed by point then time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def effect(
    config: Config,
    response_type: ResponseType,
    points: List[Point],
    weather: Optional[pd.DataFrame] = None,
    temps_bt: Optional[Tuple[List[float], List[float]]] = None,
    d: bool = False,
) -&gt; List[List[float]]:
    &#34;&#34;&#34;Temperature effect at points for some weather data.

    The returned responses contain the post-processing necessary for strain.

    Args:
        config: Config, simulation configuration object.
        response_type: type of sensor response to temp. effect.
        points:  points at which to calculate temperature effect.
        weather: DataFrame to calculate temperature profile time series from.
        temps_bt: if &#39;weather&#39; is not provided you can pass in a tuple of the
            temperature at the bottom and top of the bridge deck.
        d: a flag for debugging.

    Returns: NumPy array of temperature effect, indexed by point then time.

    &#34;&#34;&#34;
    print_w(&#34;Make sure calculating profile from entire year!!&#34;)
    # Unit effect from uniform temperature loading.
    uniform_responses = sim.responses.load(
        config=config, response_type=response_type, temp_deltas=(1, None)
    )
    linear_responses = sim.responses.load(
        config=config, response_type=response_type, temp_deltas=(None, 1)
    )
    if response_type.is_strain():
        uniform_responses = uniform_responses.add_temp_strain(config=config, temp_deltas=(1, None))
        linear_responses = linear_responses.add_temp_strain(config=config, temp_deltas=(None, 1))
    print_i(&#34;Loaded unit temperature responses&#34;)

    # Effect to unit temperature loading only at requested points.
    unit_uniforms = np.array(uniform_responses.at_decks(points))
    unit_linears = np.array(linear_responses.at_decks(points))
    assert len(unit_uniforms.shape) == 1
    assert unit_uniforms.shape[0] == len(points)

    # Determine temperature profile.
    if temps_bt is None:
        temps_bt = temp_profile(temps=weather[&#34;temp&#34;], solar=weather[&#34;solar&#34;])
    temps_bottom, temps_top = np.array(temps_bt[0]), np.array(temps_bt[1])
    temps_half = (temps_bottom + temps_top) / 2
    temps_linear = temps_top - temps_bottom
    temps_uniform = temps_half - config.bridge.ref_temp_c

    # print(f&#34;temps_bottom.shape = {temps_bottom.shape}&#34;)
    # print(f&#34;temps_top.shape = {temps_top.shape}&#34;)
    # print(f&#34;temps_half.shape = {temps_half.shape}&#34;)
    print_d(D, f&#34;tb = {temps_bottom[:3]}&#34;)
    print_d(D, f&#34;tt = {temps_top[:3]}&#34;)
    print_d(D, f&#34;th = {temps_half[:3]}&#34;)
    print_d(D, f&#34;temps linear = {temps_linear[:3]}&#34;)
    print_d(D, f&#34;temps uniform = {temps_uniform[:3]}&#34;)

    # Combine uniform and linear responses.
    uniform_responses = np.array(
        [unit_uniform * temps_half for unit_uniform in unit_uniforms]
    )
    linear_responses = np.array(
        [unit_linear * temps_linear for unit_linear in unit_linears]
    )
    # print(f&#34;uniform_responses.shape = {uniform_responses.shape}&#34;)
    # print(f&#34;linear_responses.shape = {linear_responses.shape}&#34;)
    print_d(D, f&#34;uniform responses = {uniform_responses[:3]}&#34;)
    print_d(D, f&#34;linear responses = {linear_responses[:3]}&#34;)
    if d:
        return temps_uniform, temps_linear, uniform_responses + linear_responses
    return uniform_responses + linear_responses</code></pre>
</details>
</dd>
<dt id="bridge_sim.temperature.from_to_mins"><code class="name flex">
<span>def <span class="ident">from_to_mins</span></span>(<span>df:Â pandas.core.frame.DataFrame, from_:Â datetime.datetime, to:Â datetime.datetime) ->Â pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Minutely weather data interpolated into a range (inclusive).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong></dt>
<dd>weather data loaded with 'load'.</dd>
<dt><strong><code>from_</code></strong></dt>
<dd>datetime of the first minute in the range.</dd>
<dt><strong><code>to</code></strong></dt>
<dd>datetime of the last minute in the range.</dd>
</dl>
<p>Returns: a DataFrame with values interpolated in the given range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_to_mins(df: pd.DataFrame, from_: datetime, to: datetime) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Minutely weather data interpolated into a range (inclusive).

    Args:
        df: weather data loaded with &#39;load&#39;.
        from_: datetime of the first minute in the range.
        to: datetime of the last minute in the range.

    Returns: a DataFrame with values interpolated in the given range.

    &#34;&#34;&#34;
    # Create times and temperatures from given data.
    dates, temps, solar = df[&#34;datetime&#34;], df[&#34;temp&#34;], df[&#34;solar&#34;]
    times = dates.apply(lambda d: datetime.timestamp(d))
    # Create times that are expected to return.
    result_dates, result_times = [], []
    curr = from_
    while curr &lt;= to:
        result_dates.append(curr)
        result_times.append(datetime.timestamp(curr))
        curr += timedelta(minutes=1)
    # Interpolate to get results.
    result_temps = interp1d(times, temps, fill_value=&#34;extrapolate&#34;)(result_times)
    result_solar = interp1d(times, solar, fill_value=&#34;extrapolate&#34;)(result_times)
    # Pack it into a DataFrame.
    df = pd.DataFrame(
        np.array([result_dates, result_temps, result_solar]).T,
        columns=[&#34;datetime&#34;, &#34;temp&#34;, &#34;solar&#34;],
    )
    # Sort.
    df = df.sort_values(by=[&#34;datetime&#34;])
    df[&#34;temp&#34;] = pd.to_numeric(df[&#34;temp&#34;])
    df[&#34;solar&#34;] = pd.to_numeric(df[&#34;solar&#34;])
    return df</code></pre>
</details>
</dd>
<dt id="bridge_sim.temperature.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>name:Â str, temp_quantile:Â Tuple[float,Â float]Â =Â (0.001,Â 0.999)) ->Â pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Load weather data from a file.</p>
<p>The returned DataFrame will have duplicate datetimes removed, will have NaN
and INF values removed and will have 'temp_quantile' lower and upper
quantiles removed. Missing values will NOT be filled in.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>name of the file to load (without extension).</dd>
<dt><strong><code>temp_quantile</code></strong></dt>
<dd>tuple of lower and upper air temperature quantiles to
ignore (incase of extreme values).</dd>
</dl>
<p>Returns: a DataFrame of datetimes, air temperature and solar radiation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(
    name: str, temp_quantile: Tuple[float, float] = (0.001, 0.999)
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Load weather data from a file.

    The returned DataFrame will have duplicate datetimes removed, will have NaN
    and INF values removed and will have &#39;temp_quantile&#39; lower and upper
    quantiles removed. Missing values will NOT be filled in.

    Args:
        name: name of the file to load (without extension).
        temp_quantile: tuple of lower and upper air temperature quantiles to
            ignore (incase of extreme values).

    Returns: a DataFrame of datetimes, air temperature and solar radiation.

    &#34;&#34;&#34;
    # If the file is already parsed, return it..
    name_path = os.path.join(project_dir(), &#34;data/temperature&#34;, name + &#34;.txt&#34;)
    saved_path = name_path + &#34;.parsed&#34;
    if os.path.exists(saved_path):
        df = pd.read_csv(saved_path, index_col=0, parse_dates=[&#34;datetime&#34;])
        lq = df[&#34;temp&#34;].quantile(temp_quantile[0])
        hq = df[&#34;temp&#34;].quantile(temp_quantile[1])
        print(f&#34;Temperature {temp_quantile} quantiles = {lq}, {hq}&#34;)
        df = df[(df[&#34;temp&#34;] &gt;= lq) &amp; (df[&#34;temp&#34;] &lt;= hq)]
        return df
    # ..otherwise read and parse the data.
    with open(name_path) as f:
        temps = list(map(parse_line, f.readlines()))
    # Remove NANs.
    for line_ind, [dt, temp, solar] in enumerate(temps):
        if np.isnan(temp):
            print_i(f&#34;NAN in {name} temperature&#34;)
            temps[line_ind][1] = temps[line_ind - 1][1]
        if np.isnan(solar):
            print_i(f&#34;NAN in {name} solar radiation&#34;)
            temps[line_ind][2] = temps[line_ind - 1][2]
    # Pack it into a DataFrame.
    df = pd.DataFrame(temps, columns=[&#34;datetime&#34;, &#34;temp&#34;, &#34;solar&#34;])
    # Remove duplicate datetimes.
    len_before = len(df)
    df = df.drop_duplicates(subset=[&#34;datetime&#34;], keep=&#34;first&#34;)
    len_after = len(df)
    print_i(f&#34;Removed {len_before - len_after} duplicates, now {len_after} rows&#34;)
    # Sort by datetime.
    df = df.sort_values(by=[&#34;datetime&#34;])
    # Save to file and return that DataFrame.
    df.to_csv(saved_path)
    return load(name=name)</code></pre>
</details>
</dd>
<dt id="bridge_sim.temperature.parse_line"><code class="name flex">
<span>def <span class="ident">parse_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a line of NOAA weather data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>line</code></strong></dt>
<dd>a line of NOAA weather data.</dd>
</dl>
<p>Returns: a tuple of (datetime, air temperature, solar radiation).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_line(line: str):
    &#34;&#34;&#34;Parse a line of NOAA weather data.

    Args:
        line: a line of NOAA weather data.

    Returns: a tuple of (datetime, air temperature, solar radiation).

    &#34;&#34;&#34;
    # 23803 20190101 0005 20181231 1805      3  -89.43   34.82    12.4
    # 0.0      0 0    10.9 C 0    88 0 -99.000 -9999.0  1115 0   0.79 0
    line = line.split()
    ds = line[1]  # Date string.
    ts = line[2]  # Time string.
    year, mon, day, hr, mn = (ds[0:4], ds[4:6], ds[6:8], ts[0:2], ts[2:4])
    # 2011-11-04T00:05
    dt = datetime.fromisoformat(f&#34;{year}-{mon}-{day}T{hr}:{mn}&#34;)
    return [dt, float(line[-15]), float(line[-13])]</code></pre>
</details>
</dd>
<dt id="bridge_sim.temperature.regress_and_errors"><code class="name flex">
<span>def <span class="ident">regress_and_errors</span></span>(<span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear regression predictor, and error from each given point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regress_and_errors(x, y):
    &#34;&#34;&#34;Linear regression predictor, and error from each given point.&#34;&#34;&#34;
    lr = LinearRegression().fit(x.reshape(-1, 1), y)
    errors = []
    for x_, y_ in zip(x, y):
        errors.append(abs(y_ - lr.predict([[x_]])[0]))
    return lr, np.array(errors)</code></pre>
</details>
</dd>
<dt id="bridge_sim.temperature.remove_daily"><code class="name flex">
<span>def <span class="ident">remove_daily</span></span>(<span>num_samples, signal)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove from the given signal by interpolating at 'num_samples' points.</p>
<p>Data must be of shape n samples x f features.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_samples</code></strong></dt>
<dd>number of samples e.g. 24.</dd>
<dt><strong><code>signal</code></strong></dt>
<dd>the temperature or feature signal.</dd>
</dl>
<p>Returns: a tuple of the interpolated signal, and the signal to remove.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_daily(num_samples, signal):
    &#34;&#34;&#34;Remove from the given signal by interpolating at &#39;num_samples&#39; points.

    Data must be of shape n samples x f features.

    Args:
        num_samples: number of samples e.g. 24.
        signal: the temperature or feature signal.

    Returns: a tuple of the interpolated signal, and the signal to remove.

    &#34;&#34;&#34;
    # &#39;num_samples + 1&#39; indices into given signal.
    indices = list(map(int, np.linspace(0, len(signal) - 1, num_samples + 1)))
    # Mean value of the signal between each pair of indices,
    # and new indices, at center between each pair of indices.
    y_samples, new_indices = [], []
    for i_lo, i_hi in zip(indices[:-1], indices[1:]):
        y_samples.append(np.mean(signal[i_lo:i_hi]))
        new_indices.append(int((i_lo + i_hi) / 2))
    rm = interp1d(new_indices, y_samples, fill_value=&#34;extrapolate&#34;)(
        np.arange(len(signal))
    )
    return rm, deepcopy(rm) - rm[0]</code></pre>
</details>
</dd>
<dt id="bridge_sim.temperature.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>temps:Â List[float], tmin:Â Union[int,Â NoneType]Â =Â None, tmax:Â Union[int,Â NoneType]Â =Â None, year:Â Union[int,Â NoneType]Â =Â None) ->Â List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Resize temperatures into a range.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>temps</code></strong></dt>
<dd>a list of temperatures.</dd>
<dt><strong><code>tmin</code></strong></dt>
<dd>minimum temperature in returned range.</dd>
<dt><strong><code>tmax</code></strong></dt>
<dd>maximum temperature in returned range.</dd>
<dt><strong><code>year</code></strong></dt>
<dd>preset values for tmin and tmax, 2018 or 2019. If given there's no
need to provide the tmin and tmax values.</dd>
</dl>
<p>Returns: the given temperatures interpolated into a new range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize(
        temps: List[float],
        tmin: Optional[int] = None,
        tmax: Optional[int] = None,
        year: Optional[int] = None,
) -&gt; List[float]:
    &#34;&#34;&#34;Resize temperatures into a range.

    Args:
        temps: a list of temperatures.
        tmin: minimum temperature in returned range.
        tmax: maximum temperature in returned range.
        year: preset values for tmin and tmax, 2018 or 2019. If given there&#39;s no
            need to provide the tmin and tmax values.

    Returns: the given temperatures interpolated into a new range.

    &#34;&#34;&#34;
    if year is not None:
        if year == 2018:
            tmin, tmax = -2, 32
        elif year == 2019:
            tmin, tmax = -5, 35
        else:
            raise NotImplementedError(f&#34;Unknown year {year}&#34;)
    assert tmin &lt; 0
    assert tmax &gt; 30
    print_i(f&#34;Resizing temps into: T_min, T_max = ({tmin}, {tmax})&#34;)
    return interp1d(
        np.linspace(min(temps), max(temps), 10000), np.linspace(tmin, tmax, 10000)
    )(temps)</code></pre>
</details>
</dd>
<dt id="bridge_sim.temperature.temp_profile"><code class="name flex">
<span>def <span class="ident">temp_profile</span></span>(<span>temps:Â List[float], solar:Â List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom and top bridge deck temperatures for given weather data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>temps</code></strong></dt>
<dd>list of air temperature.</dd>
<dt><strong><code>solar</code></strong></dt>
<dd>list of solar radiation.</dd>
</dl>
<p>Returns: tuple of two lists, bottom and top bridge deck temperatures.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temp_profile(temps: List[float], solar: List[float]):
    &#34;&#34;&#34;Bottom and top bridge deck temperatures for given weather data.

    Args:
        temps: list of air temperature.
        solar: list of solar radiation.

    Returns: tuple of two lists, bottom and top bridge deck temperatures.

    &#34;&#34;&#34;
    bd = 0.001

    temps_b = [temps[0]]
    for i, temp_a in enumerate(temps[1:]):
        temps_b.append((1 - bd) * temps_b[i - 1] + bd * temp_a)

    sn = 0.008
    ss = 0.0001
    temps_s = [temps[0]]

    for i, (temp_a, solar) in enumerate(zip(temps[1:], solar[1:])):
        if False:
            recent_max = np.max(temps[max(0, recent_start) : i])
            temps_s.append((1 - sd) * temps_s[i - 1] + sd * recent_max)
        else:
            temps_s.append((1 - sn - ss) * temps_s[i - 1] + sn * temp_a + ss * solar)

    return np.array(temps_b), np.array(temps_s)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bridge_sim" href="../index.html">bridge_sim</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="bridge_sim.temperature.effect" href="#bridge_sim.temperature.effect">effect</a></code></li>
<li><code><a title="bridge_sim.temperature.from_to_mins" href="#bridge_sim.temperature.from_to_mins">from_to_mins</a></code></li>
<li><code><a title="bridge_sim.temperature.load" href="#bridge_sim.temperature.load">load</a></code></li>
<li><code><a title="bridge_sim.temperature.parse_line" href="#bridge_sim.temperature.parse_line">parse_line</a></code></li>
<li><code><a title="bridge_sim.temperature.regress_and_errors" href="#bridge_sim.temperature.regress_and_errors">regress_and_errors</a></code></li>
<li><code><a title="bridge_sim.temperature.remove_daily" href="#bridge_sim.temperature.remove_daily">remove_daily</a></code></li>
<li><code><a title="bridge_sim.temperature.resize" href="#bridge_sim.temperature.resize">resize</a></code></li>
<li><code><a title="bridge_sim.temperature.temp_profile" href="#bridge_sim.temperature.temp_profile">temp_profile</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>